#
#  RIOT gdbinit
#


# GDB Initialization file when using debugger in command line mode via jtag server
#

#set logging file gdb.log
#set logging on

# When analyzing code from .text use .exe file instead of reading it from the target
# This improves the responsiveness when debugging over a slow link (e.g USB).
set trust-readonly on

# Limit backtrace
set backtrace limit 20

set print entry-values no

# Long time out for slow RTL simulators
set remotetimeout 240

# Turn instruction tracing off or on (0 or 1) in RTL and System C HW/SW Cosimulations
define itrace
    monitor ethtag_insn_trace_en $arg0
end

################################################################################
# Dump trace buffer in form suitable for analysis by aps3-tracebuf
################################################################################
define dump_trace
  set $size = *(unsigned*)0x50001008
  dump binary value trace_buf.raw $size
  append binary value trace_buf.raw *(unsigned*)0x50001004
  append binary value trace_buf.raw $r0
  append binary value trace_buf.raw $r1
  append binary value trace_buf.raw $r2
  append binary value trace_buf.raw $r3
  append binary value trace_buf.raw $r4
  append binary value trace_buf.raw $r5
  append binary value trace_buf.raw $r6
  append binary value trace_buf.raw $r7
  append binary value trace_buf.raw $r8
  append binary value trace_buf.raw $r9
  append binary value trace_buf.raw $r10
  append binary value trace_buf.raw $r11
  append binary value trace_buf.raw $r12
  append binary value trace_buf.raw $r13
  append binary value trace_buf.raw $r14
  append binary value trace_buf.raw $r15
  append binary memory trace_buf.raw (0x51000000) (0x51000000+($size*8))
  printf "Finished dumping trace buffer to trace_buf.raw\n"
end
document dump_trace
  Dump out the trace buffer to trace_buf-raw
  suitable for further postprocessing with the trace_buf program.
end
define show_trace
  printf "ptr = %d (0x%x)\n", *(unsigned*)(0x50001004), *(unsigned*)(0x50001004)
  set $i = 0
  set $size = *(unsigned*)0x50001008
  while $i < $size
    printf "%5d:  %3d  %08x\n", $i, *(unsigned*)(0x51000004 + $i*8), *(unsigned*)(0x51000000 + $i*8)
    set $i = $i + 1
  end
end
document show_trace
  Display the raw contents of the trace buffer.
end  

#################################################################################
# cmdline commands (normally handled by eclipse)
################################################################################
target remote:3333

load

#################################################################################
# Reset various bits of HW
################################################################################

# Reset interrupt controller interrupts [0..7] inclusive
set *(unsigned*)0x40000000=0
set *(unsigned*)0x40000004=0
set *(unsigned*)0x40000008=0
set *(unsigned*)0x4000000c=0
set *(unsigned*)0x40000010=0
set *(unsigned*)0x40000014=0
set *(unsigned*)0x40000018=0
set *(unsigned*)0x4000001c=0

# Reset counter: value, reload, expired, mask
set *(unsigned*)0x40002000=0xffffffff
set *(unsigned*)0x40002004=0xffffffff
set *(unsigned*)0x40002008=0
set *(unsigned*)0x4000200c=0


#################################################################################
# FIXME:  source ./gdbinit-riot-helpers 
################################################################################
#
#  RIOT HELPERS
#
#################################################################################
# 
################################################################################

#check if DEVELHELP enabled 
#(FIXME: there is no gdb ignore-error mode in command line
# so if the symbol does not exist (i.e. p DEVELHELP), this 
# script will exit on error. an ugly workaround is to init 
# it at the very end of this script, or only once in an 
# interractive command... or with a python script (nok aps-gdb))
set $DVH=0
set $DVH_inited=0
define ini_once_DVH
  if ($DVH_inited==0)
	set $DVH_inited=1
	#here we may fail.
  	#set $DVH=__aps_develhelp
  	set $DVH=DEVELHELP
  end
end

define gdb_timer_cap
  set timer1_capa->capture = 0
  set timer1_capa->status  = 0
  set timer1_capa->enable  = 1
  set timer1_capa->capture = 1
  while timer1_capa->status != 1
  end
  set $timer_value = timer1_capa->value
  set timer1_capa->status  = 0
  set timer1_capa->capture = 0
end

define gdb_timer_set_offset
  set $offset = $arg0
  set timer1_cmpa->enable = 0
  set timer1_cmpa->status = 0
  gdb_timer_cap
  set timer1_cmpa->compare = $timer_value + $offset
  set timer1_cmpa->enable = 1
  continue
end

define gdb_timer_read
  gdb_timer_cap
  printf "timer1 value = %d\n", $timer_value
end

define bti
  set $addr=(unsigned int)$arg0
  #
  # do a backtrace from an interrupt context
  # !!!inconsitent context if interrupted while printing!!!
  #
  # gdb needs r1,r15,pc + all other registers to reconstruct a proper backtrace
  p /a $addr
  list $addr
  info symbol $addr
end


set $curr_regs_save=0
set $curr_regs_restore=0

define regs_save
  if ($curr_regs_save != $curr_regs_restore)
    printf "WARNING: registers do not seem to have been restored - skip save\n"
    return 0
  else
    set $curr_pid  = sched_active_thread->pid
    set $curr_r1   = $r1
    set $curr_r2   = $r2
    set $curr_r3   = $r3
    set $curr_r4   = $r4
    set $curr_r5   = $r5
    set $curr_r6   = $r6
    set $curr_r7   = $r7
    set $curr_r8   = $r8
    set $curr_r9   = $r9
    set $curr_r10  = $r10
    set $curr_r11  = $r11
    set $curr_r12  = $r12
    set $curr_r13  = $r13
    set $curr_r14  = $r14
    set $curr_r15  = $r15
    set $curr_psr  = $psr
    set $curr_pc   = $pc
    set $curr_regs_save += 1
  end
end

define regs_restore
  if ($curr_regs_save <= $curr_regs_restore)
    printf "WARNING: registers do not seem to have been saved - skip restore\n"
    return 0
  else
    select-frame 0
    set $r1   = $curr_r1
    set $r2   = $curr_r2
    set $r3   = $curr_r3
    set $r4   = $curr_r4
    set $r5   = $curr_r5
    set $r6   = $curr_r6
    set $r7   = $curr_r7
    set $r8   = $curr_r8
    set $r9   = $curr_r9
    set $r10  = $curr_r10
    set $r11  = $curr_r11
    set $r12  = $curr_r12
    set $r13  = $curr_r13
    set $r14  = $curr_r14
    set $r15  = $curr_r15
    set $psr  = $curr_psr
    set $pc   = $curr_pc
    set $curr_regs_restore += 1
  end
end

define regs_load
  set $tsp=$arg0
  if ($curr_regs_save <= $curr_regs_restore)
    printf "WARNING: registers do not seem to have been saved - skip load\n"
    return 0
  else
    select-frame 0
    set $r1  =                 $tsp + 0x44
    # set $tmrk=*(unsigned int*)($tsp + 0x40)
    set $tpsr=*(unsigned int*)($tsp + 0x3c)
    set $pc  =*(unsigned int*)($tsp + 0x38)
    set $r15 =*(unsigned int*)($tsp + 0x34)
    set $r14 =*(unsigned int*)($tsp + 0x30)
    set $r13 =*(unsigned int*)($tsp + 0x2c)
    set $r12 =*(unsigned int*)($tsp + 0x28)
    set $r11 =*(unsigned int*)($tsp + 0x24)
    set $r10 =*(unsigned int*)($tsp + 0x20)
    set $r9  =*(unsigned int*)($tsp + 0x1c)
    set $r8  =*(unsigned int*)($tsp + 0x18)
    set $r7  =*(unsigned int*)($tsp + 0x14)
    set $r6  =*(unsigned int*)($tsp + 0x10)
    set $r5  =*(unsigned int*)($tsp + 0x0c)
    set $r4  =*(unsigned int*)($tsp + 0x08)
    set $r3  =*(unsigned int*)($tsp + 0x04)
    set $r2  =*(unsigned int*)($tsp + 0x00)
  end
end

define _switch_thread_nocheck
  set $pid=$arg0
  
  set $tsp=(unsigned int)(sched_threads[$pid]->sp)
  if ($DVH == 1)
	set $name=            sched_threads[$pid]->name
  end
  if ($tsp == 0)
    # the thread is currently running.
    # we know that because we reset thread->sp=0x0 after a context_restore
    set $tpsr=$psr
    set $tmrk=0
    printf "===Thread#%d=== ", $pid
  else
    # the thread is currently switched out,
    # we know that because we set thread->sp=r1 after a context_save
    # let's fool gdb by pointing to the saved context
    regs_load $tsp
    set $tmrk=*(unsigned int*)($tsp + 0x40)
    printf "---Thread#%d--- ", $pid 
  end
  if ($DVH==1)
    printf "r1=[0x%08x] pc=[0x%x] psr=[0x%x] mrk=[%d] <%s>\n", $r1, $pc, $tpsr, $tmrk, $name
  else
    printf "r1=[0x%08x] pc=[0x%x] psr=[0x%x] mrk=[%d]\n", $r1, $pc, $tpsr, $tmrk
  end
  bt
end

define switch_thread
  ini_once_DVH
  set $pid=$arg0
  regs_save
  #do not regs_restore automatically here, we are not sure what happened before
  
  if ($pid <= 0) || ($pid > sched_num_threads)
    printf "ERROR: invalid thread pid (0 < #%d < %d)\n", $pid, sched_num_threads
  else
    printf "WARNING: do a regs_restore when finished!\n"
    _switch_thread_nocheck $pid
  end
end

define btt
  ini_once_DVH
  #
  # do a backtrace for all riot threads (~ 'frame addr')
  # !!!inconsitent context if interrupted while printing!!!
  #
  # gdb needs r1,r15,pc + all other registers to reconstruct a proper backtrace
  set $i = 0
  while ++$i <= sched_num_threads
    regs_save    
    _switch_thread_nocheck $i
    regs_restore
    printf "\n"
  end
end

define _set_status_str
  #define STATUS_STOPPED              0   /**< has terminated                     */
  #define STATUS_SLEEPING             1   /**< sleeping                           */
  #define STATUS_MUTEX_BLOCKED        2   /**< waiting for a locked mutex         */
  #define STATUS_RECEIVE_BLOCKED      3   /**< waiting for a message              */
  #define STATUS_SEND_BLOCKED         4   /**< waiting for message to be delivered*/
  #define STATUS_REPLY_BLOCKED        5   /**< waiting for a message response     */
  #define STATUS_FLAG_BLOCKED_ANY     6   /**< waiting for any flag from flag_mask*/
  #define STATUS_FLAG_BLOCKED_ALL     7   /**< waiting for all flags in flag_mask */
  #define STATUS_MBOX_BLOCKED         8   /**< waiting for get/put on mbox        */
  #define STATUS_RUNNING          9       /**< currently running                  */
  #define STATUS_PENDING         10       /**< waiting to be scheduled to run     */
  if ($arg0 == 0)
    $_status_str = "stop"
    return $arg0
  end
  if ($arg0 == 1)
    $_status_str = "sleep"
    return $arg0
  end
  if ($arg0 == 2)
    $_status_str = "mtx_bl"
    return $arg0
  end
  if ($arg0 == 3)
    $_status_str = "rcv_bl"
    return $arg0
  end
  if ($arg0 == 4)
    $_status_str = "snd_bl"
    return $arg0
  end
  if ($arg0 == 5)
    $_status_str = "rsp_bl"
    return $arg0
  end
  if ($arg0 == 6)
    $_status_str = "flgany"
    return $arg0
  end
  if ($arg0 == 7)
    $_status_str = "flgall"
    return $arg0
  end
  if ($arg0 == 8)
    $_status_str = "mbx_bl"
    return $arg0
  end
  if ($arg0 == 9)
    $_status_str = "run"
    return $arg0
  end
  if ($arg0 == 10)
    $_status_str = "pend"
    return $arg0
  end
end

define ptt
  ini_once_DVH
  #
  # print riot threads summary (~ ps)
  #
  set $i = 0
  while ++$i <= sched_num_threads
    if ($DVH==1)
	  set $name   =            sched_threads[$i]->name
	end
    set $pid    =              sched_threads[$i]->pid
    set $prio   =              sched_threads[$i]->priority
    set $status =              sched_threads[$i]->status
    #set $rq     =              sched_threads[$i]->rq_entry.next
    #_set_status_str
    set $tsp    =(unsigned int)sched_threads[$i]->sp
    if ($tsp == 0)
      set $tsp = (unsigned int)$r1
      printf "===Thread#%d=== ", $i
    else
      printf "---Thread#%d--- ", $i
    end
    if ($DVH==1)
      set $stk_sz = (unsigned int)sched_threads[$i]->stack_size
      set $stk_use=((unsigned int)sched_threads[$i]->stack_start+(unsigned int)sched_threads[$i]->stack_size)-(unsigned int)$tsp
      printf "r1=[0x%08x] prio=[%2d] st=[%2d] sz[%4d] use[%4d] <%s>\n", $tsp, $prio, $status, $stk_sz, $stk_use, $name
      #printf "r1=[0x%08x] prio=[%2d] st=[%2d] sz[%4d] use[%4d] rq=[0x%08x] <%s>\n", $tsp, $prio, $status, $stk_sz, $stk_use, $rq, $name
    else
      printf "r1=[0x%08x] prio=[%2d] st=[%2d]\n", $tsp, $prio, $status
    end
  end

  if ($argc == 1 )
    if ($arg0 > 0) && ($arg0 <= sched_num_threads)
      p *sched_threads[$arg0]
    end
  end
  
end

define pdbg
  p __aps_debug.xtimcb[__aps_debug.xtimcb[0].idx]
  p __aps_debug.timset[__aps_debug.timset[0].idx]
end

# print only ethernet frames len
# static int _send(netdev_t *netdev, const struct iovec *vector, unsigned count)
define pethos_send
  set $c = count
  set $v = vector
  set $len=(int)0
  while ($c > 0)
    set $c = $c -1
    set $len = $len + (int)((struct iovec *)$v+$c)->iov_len 
  end
  printf "ethos_snd(%d)=%d\n",count, $len
end

define pethos_eof
  if (dev->frametype == 0)
    set $inbuf = &(dev->inbuf->buf[dev->inbuf->reads & (dev->inbuf->size-1)])
    printf "-> eof %d/%d (%02x %02x %02x)\n", dev->framesize, (dev->inbuf->writes-dev->inbuf->reads), *(char*)($inbuf), *(char*)($inbuf+1), *(char*)($inbuf+2)
  end
end

# Fix a bug when ethos flooded
# (gnrc has not the time to get last frame before it is replaced...)
define ethos_reset
  set ethos.inbuf.reads=0
  set ethos.inbuf.writes=0
  set ethos.last_framesize=0
  set ethos.framesize=0
end
  
define gnrc_pktbuf_dump
  set $sz_unused=0
  set $sz_tot=sizeof(_pktbuf)
  set $err_cnt=0
  set $ptr  = (_unused_t *)_first_unused
  set $b0 = &_pktbuf[0]
  set $bs = sizeof(_pktbuf)
  set $be = &_pktbuf[0]+$bs
  set $pused= $b0
  while ((int)$ptr != 0)
    if ((int)$b0 > (int)$ptr) || ((int)$ptr >= (int)$be)
      printf "ERROR1 0x%0x\n", $ptr
      set $err_cnt += 1
    end
    if ((int)($ptr->next) != 0) && ((int)$ptr >= (int)($ptr->next))
      printf "ERROR2 0x%0x\n", $ptr
      set $err_cnt += 1
    end
    if ((((int)($ptr->next) == 0) || ($ptr->size > (size_t)((uint8_t *)($ptr->next) - (uint8_t *)$ptr))) && (($ptr->next != 0) || ($ptr->size != (size_t)($bs - ((uint8_t *)$ptr - $b0)))))
      printf "ERROR3 0x%0x\n", $ptr
      set $err_cnt += 1
    end
    #used chuncks:
    printf "(%x+%x)", (int)$pused, (int)((int)$ptr-(int)$pused)
    #p /x *(gnrc_pktsnip_t*)$pused
    #p /x *(ethernet_hdr_t*)((gnrc_pktsnip_t*)$pused)->data
    #p /x *(ipv6_hdr_*)0x2340
    #unused chuncks:
    # p/x *(_unused_t*)$ptr
    printf "[%x+%x]", (int)$ptr, $ptr->size
    set $sz_unused += $ptr->size
    set $pused = (int)$ptr + (int)$ptr->size
    set $ptr = $ptr->next
  end
  printf "(%x+%d)\n", (int)$pused, (int)((int)$be-(int)$pused)
  printf "\nDONE: ERR=%d, UNUSED/TOT=%d/%d  *[unused](used?)\n", $err_cnt, $sz_unused, $sz_tot 
end

define gnrc_pktbuf_reset
  set _first_unused = &_pktbuf
  set _first_unused->next = 0
  set _first_unused->size = sizeof(_pktbuf)
end

#################################################################################
#
# Automatic breakpoints
#
#################################################################################

# prevent errors if trying to break on undefined symbols.
set breakpoint pending on

## 1 ##
br gnrc_netapi_dispatch
commands
  silent
  frame 0
  c
end

## 2 ##
#br ethos_send_frame  : used only for stdio and hello frames
br -source drivers/ethos/ethos.c -function _send
commands
  silent
  pethos_send
  c
end

## 3 ##
br _end_of_frame
commands
  silent
  pethos_eof
  c
end

## 4 ##
br tsrb_dropr
commands
  c
end

dis 
#################################################################################
#
#################################################################################
set output-radix 16
set print pretty on
set pagination off

br main
br assert_break
br _assert_failure
#br assert
br debug_break

#br gnrc_pktbuf_static.c:406
#br gnrc_pktbuf_static.c:385
#br gnrc_pktbuf_static.c:378
#br gnrc_pktbuf_static.c:198
#br gnrc_pktbuf_static.c:149
#br gnrc_pktbuf_static.c:141
#br gnrc_pktbuf_static.c:122
#br gnrc_pktbuf_static.c:99

#p /x *(ethernet_hdr_t*)(((gnrc_pktsnip_t*)_pktbuf)->data)
#p *(gnrc_pktsnip_t*)_pktbuf


#br gpio_init
#br gpio_init_int
#br gpio_irq_handler
#br gpio_read

## CC11 specific (break on errors instead of enabling traces which have side effects):
#br _netdev_cc110x_isr
#br _tx_abort (NOK: confused with switch_to_rx)


############################## Last line ########################################
ini_once_DVH
############################## Last line ########################################